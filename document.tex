%------------------------------------------------------------------------------
% Template file for the submission of papers to IUCr journals in LaTeX2e
% using the iucr document class
% Copyright 1999-2003 International Union of Crystallography
% Version 1.2 (11 December 2002)
%------------------------------------------------------------------------------
%
\documentclass[preprint]{iucr}              % DO NOT DELETE THIS LINE
                   \def\href#1{\relax}\let\foo\caption
\ifPDF
  \RequirePackage{hyperref}
  \PassOptionsToPackage{pdftex,bookmarksopen,bookmarksnumbered}{hyperref}
  \voffset=-0.5in
\fi
\let\caption\foo

\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
 \usepackage{amsmath}
%\usepackage{eps2pdf}

 \paperprodcode{a000000}      % Replace with production code if known
 \paperref{gy5006}            % Replace xx9999 with reference code if known
 \papertype{IU}               % Indicate type of article
 \paperlang{english}          % Can be english, french, german or russian
 \journalcode{S}              % Indicate the journal to which submitted
 \journalyr{2019}
 \journalreceived{\relax}
 \journalaccepted{\relax}
 \journalonline{\relax}

\begin{document}                  % DO NOT DELETE THIS LINE

\title{New tools for calibrating diffraction setups}
\shorttitle{Calibration tools in pyFAI}
 
 \cauthor[a]{J.}{Kieffer}{jerome.kieffer@esrf.eu}

 \author[a]{V.}{Valls}
 \author[b,c]{N.}{Blanc}
 \author[d,e]{C.}{Hennig}
 
 \aff[a]{ESRF, The European Synchrotron, CS40220, 38043 \city{Grenoble}
 Cedex 9, \country{France}}
 \aff[b]{University Grenoble Alpes, Grenoble INP,  38000 \city{Grenoble}, \country{France}}
 \aff[c]{CNRS, Institut NEEL, 38000 \city{Grenoble}, \country{France}}
 \aff[d]{Helmholtz-Zentrum Dresden-Rossendorf, Institute of Resource Ecology, 
Bautzner Landstrasse 400, 01328 \city{Dresden}, \country{Germany}}
 \aff[e]{The Rossendorf Beamline at ESRF, BP 220, 38043 \city{Grenoble}
 Cedex 9, \country{France}}
 \shortauthor{Kieffer & al.}


\keyword{Powder diffraction}
\keyword{translation table}
\keyword{goniometer}
\keyword{geometry calibration}
\keyword{pair distribution function}



\maketitle                        % DO NOT DELETE THIS LINE

\begin{synopsis}
New tools to calibrate different types of scattering experiments suitable for static
and moving detectors.
\end{synopsis}

\begin{abstract}


This work presents new calibration tools in the pyFAI
suite for processing scattering experiments acquired with area detectors:
a new graphical user interface for calibrating the detector position in a  
scattering experiment performed with a fixed, large area detector as well as 
a library to be used in \textit{Jupyter notebooks} for calibrating the motion
of a detector on a goniometer arm (or any other moving table) to perform
diffraction experiments.
\end{abstract}


\section{Introduction}

According to an internal survey performed among the beam-line scientists at
the European Synchrotron (ESRF) in 2016, the factor limiting the users'
productivity at diffraction beam-lines is the calibration of the experimental
setup before the raw data can be reduced to analysable data
The calibration issue is currently worked around by providing users with the
proper geometry description or even the reduced data, but this prevents the
re-processing at home institutes and also the re-interpretation of data which
is needed as a part of the open data initiative \cite{Wilkinson2016}.

At X-ray facilities like synchrotons, large area detectors are 
preferred for gathering a maximum number of photons in
scattering experiments (powder diffraction, small angle
scattering, \ldots).
% The still position of the detector during the acquisition, makes also
%easier the data-reduction step.
Using a fixed position setup combined with the speed of modern detectors (up
to a few kHz) the data acquisition is easily
performed to follow chemical reactions or other physical processes \textit{in situ}.
Even with fixed geometries, determining the detector's position is
still an issue for a majority of users. 
Hence, a new graphical user interface has been developed for pyFAI
\cite{pyFAI_0.18}, focusing on the user's experience to grant them autonomy in
data analysis, once they are back in their home institutes.

Laboratory source diffractometers
are commonly equipped with (small) area detectors mounted on moveable goniometer
arms for powder diffraction (for example, the Rigaku HyPix-3000 detector).
%The larger number of pixels trades-of the resolution for speed.
Detectors at synchrotrons are often mounted on goniometer or
translation tables to provide the degrees of freedom (hereafter $dof$) which are 
needed to aligning the beam-line, although those $dof$ are rarely used for data acquisition.
One counter-example is reported in \cite{Gao:kc5032}, where the beam-line
is equipped with a moving strip-detector, the Mythen detector (1D) from Dectris,
but the Mythen is not an area detector.

%On the opposite, moving detector setups are rarely
%used at synchrotrons for the data acquisition itself, even if most of the
% detectors are mounted on a moving table or on a goniometer. 



%High-Q diffraction signal acquisition is needed  for
Pair Distribution Function (\textsc{pdf}) analysis typically requires very large area
detectors and higher energies to be able to cover the needed high $q$-range in
one single frame \cite{Chupas:wf5000}.
When speed is not critical, \textsc{pdf} experiments could be performed
with small area detectors mounted on a motorized arm, and moved in front of
the sample during the data acquisition to cover a larger solid angle. 
A new pyFAI module which is dealing with goniometers and moving detectors is also presented.
It offers to exploit the positioning system of the detector 
(often readily available on beam-lines) to acquire powder diffraction or \textsc{pdf} data 
on larger $q$-range with no additional cost or investment.

The pyFAI library \cite{fv5028}, is first briefly introduced, 
%followed by a description of how to merge multiple diffraction images 
then the way of merging multiple diffraction images
acquired at different positions is demonstrated as in \cite{PyFAI_PDJ}. 
After summarizing how calibration works in pyFAI, the new graphical user
interface is presented.
Finally, the procedure on how to calibrate the absolute position of
every single pixel in the detector when mounted on a goniometer (or on a
translation stage) as a function of motor positions, is
described.
% assuming actuators are precise and coupled with encoders. 

\section{The Python Fast Azimuthal Integration library (pyFAI)}

PyFAI is a Python \cite{python} library used to transform 2D diffraction images into
1D powder diffraction patterns by re-binning the pixel positions in polar
coordinates. 
The radial units are typically the scattering angle  
$2\theta$ or the momentum transfer $q=4\pi \sin(\theta)/\lambda$.
PyFAI also provides additional tools to calibrate the detector position, i.e.
to determine its location in space by means of Debye-Scherrer conical rings
resulting from the intersection of the diffracted X-ray beam with the
detector surface. 
The observed rings are deformed into ellipses when the detector is planar but 
slightly inclined. 
The azimuthal integration is performed in two steps. 
The first is a pixel-wise
transformation corresponding to the image correction:

\begin{equation}
I_{cor} = \frac{signal}{normalization}  = \frac{I_{raw} - I_{dark}}{F \cdot
\Omega \cdot P \cdot A \cdot I_0} 
\end{equation}

where $I_{raw}$ is the detector's raw signal, $I_{dark}$ is the dark current
image (it may also be the background image for certain experiments), $F$ is a 
factor accounting for the flat-field correction, $\Omega$ is the solid
angle subtended by a given pixel, $P$ is the polarisation correction term and
$A$ represents the detector's apparent efficiency due to the incidence angle of the
photon on the detector (for integrating detectors, high energy photons with
larger incidence angle see larger sensor thickness, and thus have higher
detection probability).
$I_{raw}$ may be normalized by the incoming flux $I_0$, which is
independent of the pixel position.
The numerator of equation (1) will hereafter be referred as
\textit{signal}, whilst the denominator will be referred as
\textit{normalization}. 
The \textit{variance} associated to the \textit{signal} of every single pixel can be estimated 
from statistical distributions assuming for example the detecor has a Poissonian behaviour. 
This \textit{variance} needs to be scaled in a similar way when considering error propagation.

The second step is the re-binning of the data, which is carried out 
using histograms of the radial positions, 
weighted by either the \textit{signal} or \textit{normalization}
as described in \citeasnoun{kieffer_ashiotis-proc-euroscipy-2014}.
PyFAI defines many radial units, among which the scattering angle $2\theta$
and the modulus of the scattering vector $q$ are the most commonly used.
This procedure sums the \textit{signal} (resp. \textit{normalization}) for all pixels
having a radius which falls into the given radial bin .

The intensity averaged over all pixels located at a given radial value is then simply 
the ratio of the two histogram which bin corresponds to the radius of interest (2) 
while the associated error, the standard error of the mean, is given by (3):

\begin{equation}
<I>_{r} = \frac{\sum\limits_{i \in bin_r} c_i \cdot signal_i}
                        {\sum\limits_{i \in bin_r} c_i \cdot normalization_i} 
\end{equation}
\begin{equation}
\sigma_{r}(I) = \frac{\sqrt{\sum\limits_{i \in bin_r} c_i^2 \cdot variance_i}}
                  {\sum\limits_{i \in bin_r} c_i \cdot normalization_i} 
\end{equation}

In equations (2) and (3), $c_i \in [0..1]$ is used to describe pixel splitting and 
corresponds to the fraction of a pixel area falling into a specific histogram bin. 
The multiple pixel splitting schemes available in pyFAI, called full-splitting, 
bounding-box-splitting and no-splitting differ have been described in
\citeasnoun{fv5028}.

The integration scheme presented in equation (2) is an improvement over 
former versions of pyFAI (<0.18) which was using equation (4) where error propagation 
was not correct as pixels with smaller area, further away from the sample or weaker tend to be 
over-represented in the statistic.

\begin{equation}
<I>_{r} = \frac{\sum\limits_{i \in bin_r} \frac{ c_i \cdot
signal_i}{normalization_i}} {\sum\limits_{i \in bin_r} c_i} 
\end{equation}


\section{Azimuthal integration of multiple frames taken at multiple geometries}

The pyFAI integration scheme of multiple images taken at various positions has
first been reported in \citeasnoun{PyFAI_PDJ}. 
The procedure is conceptually similar to the integration on a single image,
except that all histograms need to calculated over the very same
grid to allow histograms from all images to be summed as described in (5). 

\begin{equation}
<I>_{r} = \frac{\sum\limits_{imges} \sum\limits_{i \in bin_r} c_i \cdot
signal_i} {\sum\limits_{imges} \sum\limits_{i \in bin_r} c_i \cdot
normalization_i} 
\end{equation}

The normalization for solid angle correction $\Omega$ has to be performed
using an absolute solid angle reference system (unlike the case of single
frame integration) as different geometries may have very different
sample-to-detector distances.
Hence integrated intensities in multi-geometry mode are orders of
magnitude larger than using the ``normal'' pyFAI integration methods.

\section{Calibration of the detector position}

\subsection{Principle of the calibration using a Debye-Scherrer diffraction
image}
The calibration of a detector position is performed using several Debye-Scherrer
rings collected from a reference powder called \textit{calibrant}.
The rings are extracted automatically from the image (by subtracting a smoothed 
version of the image) and control points are placed at the
local maxima on the rings.
The geometry of the experiment is obtained by refining geometric parameters using 
a least-square fitting of the $2\theta$ values calculated for the different control points.
%In this work we will call them ``rings'' even if, for planar detector,
%they are actually the conic intersections of the X-ray beam cones
%with the detector plane.
%For non-planar detectors these ``rings'' can be any curve, while on planar 
%detectors in transmission mode, they are simply ellipses.

Intuitively, the easiest geometry to perform the calibration is built upon 
the beam-center definition, which is the intersection of the direct beam with the detector. 
This geometry has been first introduced in FIT2D \cite{Hammersley:fs5107} 
and re-used in many software packages like GSAS-II \cite{Toby:aj5212} and 
Dawn \cite{Filik:vg5068} which offer more user-friendly interfaces.
The FIT2D-geometry reaches its limits when the detector is heavily tilted, and it is not 
even possible to describe a detector mounted parallel to the beam (which is sometimes used in 
reflection geometry).
The geometry used in pyFAI is based on the definition of the Point Of Normal Incidence 
(hereafter named \textsc{poni}, Figure \ref{poni}), which is 
the orthogonal projection of the sample position (the origin in pyFAI) on the detector plane (or
the plane $z=d_3=0$ when the detector is non-planar and $z$ varies from pixel to pixel).
This geometry is inspired by SPD \cite{Boesecke:aj6013} and is capable of describing any 
detector position in space. 
It is worth noting that the \textsc{poni} is co-located with the beam-center when the 
detector is not tilted, i.e. mounted orthogonal to the incident beam. 
Moreover the \textsc{poni} is more likely than the beam-center to be located within the detector's 
surface when the detector is heavily tilted (since the detector gathers more photonswhen facing the sample). 
Some geometry conversion tools are provided by pyFAI and documented in \cite{Detlefs2019}.

\begin{figure}
\label{poni}
\begin{center}
\includegraphics[width=15cm]{images/PONI}
\caption{Geometry used in pyFAI.}
\end{center}
\end{figure}

The geometrical parameters to be refined are the following:
\begin{itemize}
  \item $dist$: the distance (in metres) from the sample position to the
  \textsc{poni}.
  \item $poni_1$ and $poni_2$: space coordinates of the
  \textsc{poni} (in metres) within the detector plane ($z=d_3=0$) along the slow-
  and the fast-reading dimension of the detector image (1 and 2 usually refer to the row
  and the column axis, i.e. $y$ and $x$ respectively).
  \item $rot_1$, $rot_2$ and $rot_3$: the
  rotation angles (expressed in radians) of the detector placed at the proper
  distance from the sample, with respect to the 3 axes of the
  laboratory reference system.
  The detector is first rotated around the vertical axis ($rot_1$), then
  around the horizontal axis ($rot_2$) and finally around the
  incoming beam direction ($rot_3$). In a more mathematical way, this gives:
\begin{equation}
	R = R_3 \cdot R_2 \cdot R_1 
\end{equation}
where
\begin{equation}
	R_1 = 	
	\begin{bmatrix}
	1 & 0 & 0\\
	0 & \cos(rot_1) & \sin(rot_1) \\
	0 & -\sin(rot_1) & \cos(rot_1) \\
	\end{bmatrix}
\end{equation}
\begin{equation} 		
	R_2 =
	\begin{bmatrix}
	\cos(rot_2) & 0 & \sin(rot_2) \\
	0 & 1 & 0 \\
	-\sin(rot_1)&0 & \cos(rot_2) \\
	\end{bmatrix}
\end{equation}
\begin{equation} 	
	R_3 =
	\begin{bmatrix}
	\cos(rot_3) & -\sin(rot_3) & 0 \\
	\sin(rot_3) & \cos(rot_3) & 0\\
	0 & 0 & 1\\
	\end{bmatrix}
	\cdot 
\end{equation}

\end{itemize}
It is worth mentioned rotations $R_1$ and $R_2$ are left-handed, while 
$R_3$ is right-handed, which is a legacy from previous versions of pyFAI.

%The least-square refinement is optimizing a set of six geometrical parameters:
%the three translations corresponding to the coordinates of the \textsc{poni} and
%the three rotations corresponding on the tilt of the detector around three orthogonal axes.
%This makes seven parameters to refine when considering in addition the energy or the wavelength. 


The strength of this geometry parameterization is that it describes any detector position in
space. 
The drawback is that some parameters are correlated or not optimized:

\begin{itemize}
  \item \textit{dist-wavelength}: reducing the wavelength is nearly equivalent
  to increasing the distance unless the diffraction angle $2\theta$ is 
  large ($>30^o$). 
  It is advisable to fix one of the two variables unless the data are good
  quality and the scattering range is very large. 
  This is an intrinsic limitation of the single image approach.
  \item $rot_1$-$poni_2$ and $rot_2$-$poni_1$, as small rotations can be
  mistaken for larger translations. 
  Fixing one of the two decreases the uncertainty of the other by several orders of
  magnitude. 
  The user interface offers a ``SAXS constrains`` to lock the detector normal to the direct beam.
  \item $rot_3$ cannot be refined from Debye-Scherrer cones as they are, by definition,
  invariant by rotation around the incoming beam. 
  The $rot_3$ parameter can be
  assessed using an anisotropic contribution, like the polarization effect or
  some  textures in the sample.
  This $rot_3$ parameter is used to describe the azimuthal rotation of
  the experimental setup or of the sample, for example when calculating pole
  figures.
\end{itemize}
 
Those calibration parameters containing the geometry of the experimental setup 
are saved in a text file with the ``.poni'' extension, 
also contains the detector definition and the wavelength.
%which contains in addition the detector definition and the wavelength.
This file can subsequently be loaded into an \textit{azimuthal integrator}
object, ready to perform the azimuthal regrouping an image coming from the detector.

\subsection{Graphical user interface}

A semi-graphical calibration tool has been available as part of pyFAI
\cite{fv5028} since the origin of the project, but this tool was considered too
difficult to use by inexperienced users.
Thus, many groups have developed their own graphical user interface on top of
pyFAI, often optimized for their specific setup or experiment:
Dioptas \cite{diopta_publi} focusing on high pressure experiments, 
Dpdak \cite{dpdak} for online SAXS reduction, 
NanoPeakCell \cite{nanopeakcell} for serial crystallography,
PySAXS \cite{pysaxs}, WiSAXS or xPDFsuite \cite{xpdfsuite} to cite a few.

Following the survey conducted among the beam-line scientists of the ESRF, a
new graphical user interface (GUI) design was developed on top of pyFAI.
% in order to replace FIT2D, discontinued in 2019 \cite{fit2d-gitlab}. 
This new GUI, \textit{pyFAI-calib2}, is based on the $silx$ scientific widgets \cite{silx_v0.5.0}, 
itself based on the PyQt5 library \cite{pyqt}.  
The \textit{pyFAI-calib2} tool has been specifically designed to address the needs 
of novice users, but should perform equally well regardless to the scientific field 
or the experimental setup.
The calibration of the experimental setup based on Debye-Scherrer rings 
is carried out in five steps and presented as a software wizard with five
subsequent tabs within the graphical interface:
\begin{itemize}
  \item{Experimental settings:} This first tab lets the user select
  the wavelength (or the energy) used, the reference material used
  for calibration (called calibrant) and to choose the kind of detector, either from a 
  list of 50 provided, or by defining a new detector (Figure \ref{calib_1}),
  \item{Mask drawing:} This tab allows to mask-out unwanted regions/pixels from the
  image, either based on their intensity (thresholding) or simply by
  drawing polygons on the image. Different masks can be saved, retrieved and assembled (Figure \ref{calib_2}),
  \item{Peak picking:} Individual peaks and arc of rings can be segmented out
  (automatically) and assigned (manually) to different rings, each ring 
  being associated with a single reflection of the calibrant (Figure
  \ref{calib_3}),
  \item{Geometry fitting:} At this stage, the detector position and
  wavelength are fitted against peak positions and ring numbers. 
  Any of the  parameters can be fixed or let free for refinement.
  The (calculated) positions of the beam center and the \textsc{poni}
  and the expected positions of rings are overlaid onto the diffraction image
  to assess visually the quality of the fit. Sample, detector 
  and direct beam can also be visualized in 3D (Figure \ref{calib_4}). 
  \item{Integration:} This tab displays the 1D and 2D integrated patterns, also
  called powder diffraction profile and caked-image to further validate the
  modelling of the experimental setup (Figure \ref{calib_5}). 
  The algorithm for integrating, the pixel splitting scheme and the radial unit
  can also be selected in this tab. 
  Diffraction profiles can be saved as text-files or images as well as the
  experimental setup description file (\textsc{poni}-file) for subsequent use with other tools from
  the pyFAI suite.
\end{itemize}

\begin{figure}
\label{calib_1}
\begin{center}
\includegraphics[width=15cm]{images/1_experiment}
\caption{Experiment settings tab: load the calibration image, set the energy, the calibrant and select the detector for the subsequent analysis.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_2}
\begin{center}
\includegraphics[width=15cm]{images/2_mask}
\caption{The mask drawing tool is used to exclude pixels using a rectangular, polygonal or pencil selection. 
         Pixels can also be selected according to their value (thresholding)}
\end{center}
\end{figure}
\begin{figure}
\label{calib_3}
\begin{center}
\includegraphics[width=15cm]{images/3_picking}
\caption{The peak-picking tool automatically selects a group of contiguous local maxima in the image close to the clicked peak which then needs 
         to be assigned to the correct calibrant ring number in the right-hand side panel.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_4}
\begin{center}
\includegraphics[width=15cm]{images/4_3d_view}
\caption{In the geometry fitting tab, each variable can be fixed, or left free for refinement within a given range. 
		 A 3D representation of the experimental setup allows visualization of the relative position of the sample, the direct beam and the detector after fitting.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_5}
\begin{center}
\includegraphics[width=15cm]{images/5_cake}
\caption{The cake and integration tab displays the 1D curve and 2D integrated image with the calibrant ring positions overlaid to allow facile validation 
         of the quality of the calibration.}
\end{center}
\end{figure}

%This new graphical user interface is now available with the
%\textit{pyFAI-calib2} command and accounts for a simpler manual peak picking,
%performs automatic ring extraction, geometry fitting and exports 
%the regrouped data and the geometry. 

The online documentation of pyFAI contains a quick tutorial \cite{doc_gui}
designed for novice users to provide them with their scattering geometry in a couple of minutes.  
%All graphical interfaces in pyFAI take advantage of the masking tools and HDF5
%browsing widgets developed in the frame of the \textit{silx}
%project \cite{silx_v0.5.0}, which streamlines the development effort around data
%analysis. 
Diffraction image can be provided in HDF5 format \cite{collette_python_hdf5_2014}
or any of the dozens of file-formats supported by the FabIO library \cite{fabio}.

\section{Calibration of a detector on a moving stage}

The calibration of a detector mounted on a translation stage along the direct beam 
has successfully been exploited by Dawn \cite{Filik:vg5068} and GSAS-II \cite{Horn:co5127} 
to remove the correlation between the detector-distance and the energy of the beam. 
While those two software packages offer an intuitive user interface for those experiments, 
the modelisation of the translation stage remains hard-coded.
This section describes how to describe programatically a moving stage in pyFAI, 
calibrate the proposed model and use it to perform the azimuthal integration with many images. 

The calibration of the detector position on a fixed goniometer position can be
performed with pyFAI as long as several rings of the chosen calibrant are
present in the image and that five control points can be extracted from one
ring and at least one point from the second ring. 
Of course, more points provide a better fit but this limit of two visible rings 
may be an issue when very small area detectors are used (e.g. the ImXPAD S10).

\subsection{Transformation of geometry}

Here, the difficulty is not in the calibration, but rather in the
variety of goniometers and translation stages which may be controlled by one or 
multiple motors.
%These motors are usually coupled with encoders, such as the actual position of
%the motors is known precisely.
The goniometer description implemented in pyFAI accepts an
arbitrary number of motors attached to the goniometer/translation stage. 
% which may be named (must be named for more than one moving motor). 
Let $motors$ be the list of all $n$ motors moved during the acquisition: 
$(motor_1, motor_2, \ldots, motor_n)$. 

Calibrating the goniometer consists of:
\begin{itemize}
  \item defining a list of $m$ parameters ($params$) to describe the position of the goniometer:
  $(param_1, param_2, \ldots, param_m)$,
  \item defining six \textit{transformation functions} $\Re$ which transforms motor positions ($motors$)
  and goniometer parameters ($params$) into the six \textsc{poni}-parameters used to
  initialize an azimuthal integrator in pyFAI:
\begin{equation}
P_{pyFAI} = (dist, poni_1, poni_2, rot_1, rot_2, rot_3) = \Re_{params}(motors)
\end{equation}
  \item optimizing the parameter set of the goniometer ($params$) so that
  for any position of the motors, the detector position are expressed as
  a \textsc{poni}-parameters set.
\end{itemize}

%This \textit{transformation function} takes hence motor names, and model-parameter names 
%with their associated values (obtained after fitting), and returns
%the six individual parameters used in \textit{pyFAI} to initialize an $AzimuthalIntegrator$; it can be formally
%expressed as:



The six \textsc{poni}-parameters returned 
%contained in the \textsc{poni}-file 
are then used to
calculate the experimentally observed $2\theta_{exp}$ position of the peaks over all control
points.
Those $2\theta_{exp}$ are compared to
the theoretically expected $2\theta_{theo}$ values calculated from the calibrant d-spacing and
from the wavelength.

$$
\Delta 2\theta = 2\theta _{exp} - 2\theta _{theo} =
\arctan(\frac{r(P_{pyFAI})}{d(P_{pyFAI})}) -  2 \cdot
\arcsin(\frac{\lambda}{2d})
$$


The average of the squares of these differences is used as a cost function
to optimise those parameters using the \textit{scipy.optimize.minimize}
function from SciPy \cite{scipy}.

$$
CostFunct = \frac{ \sum\limits_{i \in CtlPts} {(\Delta 2\theta_i)^2}}
{count(CtlPts)} $$

From a computer engineering perspective, 
those \textit{transformation functions} present several contradictory challenges: 
the user should be able to express any numerical transformation (flexibilty),
but he should be prevented from executing any arbitrary code (security).  
Moreover those functions should be made persistable on disk (i.e. save) and 
allow their restoration without having to re-perform the calibration, nor 
opening any security holes. 

The \textit{NumExpr} library \cite{numexpr} allows the evaluation of 
textual mathematical formulae into numerical
functions offering an arbitrary number of parameters (or $dof$) for 
the goniometer definition and as many motors as needed.
As \textit{NumExpr} is a mathematical compiler, it cannot execute other code. 
Those mathematical expressions are then simply saved together with the motor names 
and the parameter names and values in a \textsc{json}-format for persistence.

In the follow example, the definition of those functions is simply the creation 
of an object from the 
\textit{GeometryTransformation} class (i.e. $instantiation$), with a list of
motor names, parameter names, as well as a set of six formulae, one for each of
the six \textsc{poni}-parameters.

\subsection{A simple example: the translation table}

At the  ESRF, the protein crystallography beam-lines use large pixel detectors
(typically Pilatus 6M from Dectris) placed on a translation table which allows
collection of the data at the optimal distance: shorter sample-to-detector
distances to explore the region for high-$q$ 
or longer distances for better Bragg peak separation. 

The \textit{MX-calibrate} tool from the pyFAI suite is available for
calibrating many images taken at various distances.
This can also be interpreted in terms of a goniometer setup (actually a translation stage) 
where the sample-to-detector distance is modelled as a
simple linear function of the table position:

\begin{verbatim}
from pyFAI.goniometer import GeometryTransformation
gt = GeometryTransformation(param_names = ["dist_offset", "dist_scale", 
                                        "poni1", "poni2", "rot1", "rot2"],
                            pos_names = ["position"],
                            dist_expr="position * dist_scale + dist_offset", 
                            poni1_expr="poni1",
                            poni2_expr="poni2", 
                            rot1_expr="rot1", 
                            rot2_expr="rot2", 
                            rot3_expr="0.0")
\end{verbatim}
 
In the example above, we chose to use six parameters for the goniometer
geometry, most of them matching exactly as those of pyFAI: 
$poni_1$, $poni_2$, $rot_1$
and $rot_2$. 
$rot_3$ is forced to zero while the distance is defined as a 
linear function of the motor position. 
Motor names should be declared in \textit{pos\_names} as a list, 
if not, a single motor configuration is assumed (motor named $pos$).

The content of this tutorial is available as a Jupyter
notebook \cite{ipython} and forms part of the official documentation of pyFAI
\cite{translation_table}, this document is directly visible in a web-browser. 
In addition, one can replay the notebook with Jupyter and the notebook is
self-consistent: all images are automatically downloaded and cells can be
modified or adapted.
The notebook presents the usage of the \textit{transformation function} class
together with the translation table refinement.
Initially, this set of data was calibrated using the ``MX-calibrate'' tool
that automatically extracts the control points from images taken at
ESRF ID29 beam-lines (Protein crystallography beam-line, energy: 12.75 keV) from
the metadata written in the image headers, thus a set of control points is
available prior to processing the data. 
The translation table is calibrated using all control points
and this \textit{transformation function}.
As a result, all images have been integrated azimuthally.
The Figure \ref{id29} shows the first two Bragg peaks of CeO$_2$ calibrated
using this methodology. 
The blue curve corresponds to this initial model refined; the two peaks look
``doubled'' indicating a poor modelling of the geometry.

\begin{figure}
\label{id29}
\begin{center}
\includegraphics[width=9cm]{images/TranslationTable}
\caption{Powder diffraction profile obtained from seven images acquired
at various distances from 15 to 45 centimeters. 
The translation table position is combined with 6 (resp. 8) parameters model
fitted where the $dist$ (resp. $dist$, $poni_1$ and $poni_2$) depends on the
table position.}
\end{center}
\end{figure}

To address this poor modelling, another \textit{transformation function} is
defined, with a few additional $dof$ on the \textsc{poni} position
(i.e. the translation table is not perfectly parallel to the incident beam).
%(linear dependency of the \textsc{poni} with the table position).
Once three parameters ($dist$, $poni_1$ and $poni_2$) have been re-fitted and 
all data integrated with the new model, one obtains the orange
curve in Figure \ref{id29}. 
Its peaks are much sharper than previously and the residual cost is
about five times smaller, indicating a much better fit.

This example shows that the \textsc{poni} is moving on the detector
plane by 1 \textperthousand \ horizontally and 
4 \textperthousand \ vertically.
This ``large'' vertical deviation has been confirmed by the beam-line staff and
is related to the last focusing mirror placed just before the sample, causing the
beam to deflect away from the horizontal.
Once everything is fitted, the quality of the geometry obtained is perfectly
suited to powder diffraction experiments for any detector position.

In this example, all motor positions used for calibration were withing the accessible range, 
hence we have been doing interpolation.
In the next example will check to what extent extrapolation outside the calibration range is possible.
  
\subsection{A more realistic example: a single axis goniometer}

Probably the main application of this work is to place a small sized area detector
on a goniometer $2\theta$ arm in replacement of a punctual detector (e.g. diode) for 
powder diffraction measurements. 
The initial idea was to use a small region of interest (ROI) in the center of
an area detector, and check whether it was possible to rebuild a powder diffraction pattern
when moving the detector at various goniometer angles.
This ROI has to be of limited size in the dimension orthogonal to the ring and as extended
as possible in the tangential direction, with the limit of the curvature of the ring 
(especially at low $2\theta$ angles).
We considered a ROI of 10 pixels wide within a Pilatus 100k (487x195 pixels)
which means using only 2\% of the width of the detector (different lines being used for different bins). 
By using the full detector area, one could get a seven times improvement in the signal/noise ratio
($\sqrt{487/10}$) if the movement of the detector on the goniometer was perfectly predictable.

When the detector arm is moving in the vertical plane (hence around an horizontal axis), 
a simple \textit{geometry transformation} is defined with $rot_2$ (horizontal, in radians) as a
linear transformation of the motor position, $pos$, (measured in degrees).
The scale parameter, $scale = \pi / 180$, is used to convert degrees to radians.
The other parameters $dist$, $poni_1$, $poni_2$ and $rot_1$ are directly mapped
to pyFAI's parameters.
As previously, $rot_3$ is kept fixed at zero.

\begin{verbatim}
from pyFAI.goniometer import GeometryTransformation
goniotrans = GeometryTransformation(param_names = ["dist", "poni1", "poni2", "rot1",
                                                   "rot2_offset", "rot2_scale"],
                                    dist_expr="dist", 
                                    poni1_expr="poni1",
                                    poni2_expr="poni2", 
                                    rot1_expr="rot1", 
                                    rot2_expr="rot2_scale * pos + rot2_offset", 
                                    rot3_expr="0.0")
\end{verbatim}


This example is also available in a Jupyter notebook \cite{rotation_pilatus} 
and the workflow used is depicted in Figure \ref{workflow}.
This experiment has been performed using a single module (100k) Pilatus
detector which is mounted on a vertically moving $2\theta$ arm, varying 
from 5 to 65 degrees in half-degree steps on the ROBL beam-line
\cite{Kvashnina:vv5126}, ESRF BM20.
In this experiment, 121 diffraction images of LaB$_6$
reference compound material were acquired.
Due to the small size of the detector,
some of the images present no rings at all (especially at low $2\theta$ angle),
most have only one ring and only a few images display 2 rings. 
Even if those images are technically suitable for 
static detector calibration,
they still represent a challenge due to the large 
diffraction angles ($2\theta >30^o$), the low curvature of the rings and the difficulty to 
assign the picked peaks to the proper calibrant ring number.

%The first images presenting two rings correspond to goniometer positions above
%30 degrees. 
Four images, taken at goniometer angles of 31.5, 33 and 35 and 35.5
degrees have been manually calibrated,
% using the \textit{pyFAI-calib2} tool
%presented in the previous section.
%This manual calibration is rather tedious and unstable due to the small
%curvature of the rings on the detector image. 
fixing the rotation along axis 1 of the detector ($rot_1=0$) 
to guarantee some consistency between the four images.


\begin{figure}
\label{workflow}
\begin{center}
\includegraphics[width=9cm]{images/workflow}
\caption{Workflow used to calibrate a set of 121 images collected with a Pilatus 100k
mounted on a moving $2\theta$ arm and detailed in the \textit{Jupyter Notebook} given in  
\cite{rotation_pilatus}.}
\end{center}
\end{figure}

An initial simple model with a set of parameters where $rot_2$ is equal to the
goniometer angle has first led to convergence with some constraints and
bounds.
In a second step, twenty images in the neighbourhood of the first ones were
added to the model, their peaks extracted according to the initial model and the
model refined using the control points from the twenty images.
Then, all other images were added to the model, and additional control
points were automatically extracted from all images according to the
previous geometry model.
After all constraints and bounds were removed, the model has been refined
again and used to generate a \textit{MultiGeometry} object, which is able to integrate many
images together.
After integration of all 121 images, the powder diffraction pattern displayed
in Figure \ref{bm20}, orange curve, is obtained.
All peaks of the curve appear at the correct scattering angle but
the first few peaks look exceedingly broad. 

\begin{figure}
\label{bm20}
\begin{center}
\includegraphics[width=9cm]{images/gonio_insert}
\caption{Powder diffraction pattern obtained from 121 Pilatus 100k images acquired
at goniometer angles ranging from 5 to 65 degrees on LaB6 reference sample at 16 keV. 
The insert is a close-up view on the first peak showing the sharpness of the signal depending on the model.
The orange curve correspond to the simple model where $rot_2$ depends linearly on the goniometer angle (6 $dof$).
The blue curve corresponds to an advanced model where both rotations($rot_1$ and $rot_2$) depend linearly on the goniometer angle (7 $dof$).}
\end{center}
\end{figure}


This broadening is confirmed by looking at the first ring's image, where the
goniometer angle was set to 10 degrees (Figure \ref{bm20_10}).
The expected position of the ring (dashed red line) does not properly correspond
to the actual ring (yellow on the image). 
The control points extracted and used in the fitting are plotted in blue.

\begin{figure}
\label{bm20_10}
\begin{center}
\includegraphics[width=9cm]{images/gonio_10}
\caption{Diffraction image taken with the goniometer arm at 10 degrees.
The control points are in blue and the expected ring of the simple model
($rot2=f(pos)$) is the dashed red line. This highlights the need for $rot_1$
to depend on the goniometer position.}
\end{center}
\end{figure}

The fitting procedure averaged the $rot_1$ value (rotation around the vertical axis) over all images,
but the Figure \ref{bm20_10}, which is taken on the first ring suggests this value is slightly wrong.
The images of the last rings (visible in the notebook) indicate a small offset but in the other direction.
Both shifts are small which suggests a first order correction:
another model was tested, allowing both the $rot_1$ and $rot_2$ values to scale with the 
goniometer position. 
%For larger rotation, coupling between rotation axis appears and it is advisable to rely on quaternion transformation.
After refinement, the cost function dropped by a factor two and
the low angle peaks became sharp (blue curve in Figure \ref{bm20}). 

This parameter set was saved and allowed a few other compounds to be analysed and
compared to the same pattern recorded via a moving point detector. 
The signal/noise ratio was found to be better with an acquisition time which was one order
of magnitude shorter than previously, thus opening new prospects for
the ROBL beam-line.

A third example of goniometer calibration is available in \cite{rotation_xpad}. 
It corresponds to the calibration of an ImXPAD detector \cite{BOUDET200341}
composed of 8 stripes of 7 modules, many of which are defective.
This detector is mounted on the goniometer arm at the D2AM beam-line
\cite{Ferrer:ri0008}, ESRF BM02. 
This example is conceptually the same as the the one from the ROBL beam-line,
with a few differences:
\begin{itemize}
  \item all images are fitted directly with 8 $dof$,
  \item the detector being larger, the calculation time is
        longer, especially when it comes to ring extraction,
  \item the mask needs some extra care to remove a few hot pixels,
  \item the detector is mounted rotated by 90 degrees on the arm, thus $rot_3=\pi/2$.
\end{itemize}

This generic method has even been extended to strip detectors 
like the Mythen detector manufactured by Dectris as shown in the tutorial on the 
calibration of the array of 9 Mythen detectors \cite{rotation_mythen}, mounted on 
the goniometer arm of beam-line Cristal at Synchrotron Soleil.  

\section{Outlook}

The goniometer description in this work can be adapted to
many types of goniometer.
The \textit{TransformationFunction} class presented in the manuscript may be extended
in the future to use \textit{libhkl} \cite{libhkl} which contains already many
diffractometer geometries with their associated rotation matrices. 

Different generations of pixel detectors have seen their pixel sizes
shrinking:
from $172 \mu m$ for the Pilatus, $130 \mu m$ for ImXPAD, $75 \mu m$ for the
Eiger and $55 \mu m$ for Medipix-based chips, and probably even less for
future generation detectors dedicated for coherent diffraction imaging.
As the resolution of the powder diffraction pattern obtained is often limited by the
pixel size (and the sample-detector distance), this shrinkage of
pixel sizes leads naturally to higher quality powder
diffraction patterns.
Unfortunately, to keep the area of the detector constant, one would need
to multiply the number of pixels by the square of the pixel size reduction
factor, and the associated infrastructure for read-out and data transfer
accordingly.
Moving the detector offers a flexibility which partially removes this
limitation.


\section{Conclusion}

The new graphical user interface of pyFAI has been developed to ease the
calibration of an experimental setup with static detectors, especially for
novice users.
The concept of calibration of the detector position has been extended to fit
the detector position as a function of the motion of a goniometer.   
Once a few fixed positions of the goniometer have been calibrated, a model can
be optimized to determine the detector position at any goniometer
configuration.
By acquiring multiple images at various positions, these images can be
integrated together to produce a high-$q$ powder diffraction pattern of
quality equivalent to the one acquired with a much larger detector, opening 
up new opportunities for high resolution $in-situ$ and PDF measurements. 
We believe 
 
\ack{Acknowledgements}

We would like to thank all ESRF beam-line teams for supporting the
pyFAI development, and especially David Flot from the MX-group who provided the
data of the translation table and Nils Blanc and Christoph Hennig from the the
beam-lines BM02 (D2AM) and BM20 (ROBL) (respectively) for the goniometer data. 
They gracefully provided beam time and test data to allow debugging this 
goniometer optimisation tool.
We would also like to thank the French CNRS for financing the IR-DRX project
in 2015 and 2016, which acted as a catalyst on the goniometer refinement,
and the other participants in the project, especially Serge Cohen from the
Ipanema institute, the DiffAbs and Cristal beam-lines and Frédéric-Emmanuel Picca 
from Synchrotron Soleil.
In the instrumentation services and development division (ISDD) of the ESRF  we
would like to thank V. Armando Solé, head of the data analysis unit and leader of 
the \textit{silx} project, and all our colleagues from the \textit{silx}
project:
Thomas Vincent, Henri Payno, Damien Naudet and  Pierre Knobel for their support and ideas. 
A great thank you to Carsten Detlefs for his contribution to the documentation of the geometry in pyFAI. 
Finally we would like to dedicate this article to our colleague and friend Claudio Ferrero, who suddenly passed away in 2018. 

\bibliographystyle{iucr}
\bibliography{biblio}


\end{document}
