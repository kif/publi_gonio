%------------------------------------------------------------------------------
% Template file for the submission of papers to IUCr journals in LaTeX2e
% using the iucr document class
% Copyright 1999-2003 International Union of Crystallography
% Version 1.2 (11 December 2002)
%------------------------------------------------------------------------------
%
\documentclass[preprint, pdf]{iucr}              % DO NOT DELETE THIS LINE
                   \def\href#1{\relax}\let\foo\caption
\ifPDF
  \RequirePackage{hyperref}
  \PassOptionsToPackage{pdftex,bookmarksopen,bookmarksnumbered}{hyperref}
  \voffset=-0.5in
\fi
\let\caption\foo

\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage{eps2pdf}

 \paperprodcode{a000000}      % Replace with production code if known
 \paperref{xx9999}            % Replace xx9999 with reference code if known
 \papertype{IU}               % Indicate type of article
 \paperlang{english}          % Can be english, french, german or russian
 \journalcode{J}             % Indicate the journal to which submitted
 \journalyr{2017}
 \journalreceived{\relax}
 \journalaccepted{\relax}
 \journalonline{\relax}

\begin{document}                  % DO NOT DELETE THIS LINE

\title{Calibration of experimental setups with {pyFAI}: New tools for still
detector and moving detectors}
\shorttitle{Calibration tools in pyFAI w/wo goniometer}

 \author[a]{V.}{Valls}
 \cauthor[a]{J.}{Kieffer}{jerome.kieffer@esrf.eu}
 
 
 \aff[a]{ESRF, The European Synchrotron, CS40220, 38043 \city{Grenoble}
 Cedex 9, \country{France}}
 \shortauthor{Valls and Kieffer}


\keyword{Powder diffraction}
\keyword{translation table}
\keyword{goniometer}
\keyword{geometry calibration}



\maketitle                        % DO NOT DELETE THIS LINE

\begin{synopsis}
New tools to calibrate different types of scattering experiments : static
detectors or moving detectors.
\end{synopsis}

\begin{abstract}


This work presents new calibration tools in the pyFAI
suite for processing scattering experiments acquired with area detectors:
a new graphical user interface for calibrating the detector position in a  
scattering experiment performed with a fixed, large area detector as well as 
a library to be used in \textit{Jupyter notebooks} for calibrating the motion
of a detector on a goniometer arm (or any other moving table) to perform
diffraction experiments.
\end{abstract}


\section{Introduction}

According to an internal survey performed among the beam-line scientists at
the European Synchrotron (ESRF) in 2016, the factor limiting the users'
productivity at diffraction beam-lines is the calibration of the experimental
setup before accessing to the raw data for their reduction. 
The calibration issue is currently worked around by providing users with the
proper geometry description or even the reduced data, but this prevents the
re-processing at home institutes and also the re-interpretation of data which
is needed as a part of the open data initiative.

At X-ray facilities like synchrotons, large area detectors are 
preferred for gathering a maximum number of photons in
scattering experiments (powder diffraction, small angle
scattering, \ldots).
% The still position of the detector during the acquisition, makes also
%easier the data-reduction step.
Using a fixed position setup combined with the speed of modern detectors (up
to a few kHz) the data acquisition in kinetic mode is easily performed to 
follow chemical reactions or other physical processes \cite{id15, id31}.
Even with fixed geometries, determining the detector's position is
still an issue for a majority of users. 
Hence, a new graphical user interface has been developed for pyFAI, focusing
on the user's experience to grant them autonomy in data analysis, once they
are back in their home institutes.

Differently from large facilities, lab source diffractometers
are commonly equipped with (small) area detectors mounted on moveable goniometer
arms for powder diffraction (for example, the Rigaku HyPix-3000 detector),
%The larger number of pixels trades-of the resolution for speed.
Whereas detectors at synchrotrons are often mounted on goniometer or
translation tables, those degrees of freedom are rarely used for data
acquisition.
One counter-example is reported in \cite{Gao:kc5032}, where the beamline
is equipped with a moving strip-detector, the Mythen detector from Dectris,
which is not an area detector.

%On the opposite, moving detector setups are rarely
%used at synchrotrons for the data acquisition itself, even if most of the
% detectors are mounted on a moving table or on a goniometer. 



%High-Q diffraction signal acquisition is needed  for
Pair Distribution Function (\textsc{pdf}) analysis requires very large
detectors and higher energies to be able to cover the needed high $q$-range in
one single frame \cite{Chupas:wf5000}.
When speed is not critical, \textsc{pdf} experiments could be performed
with smaller detectors mounted on a motorized arm, and moved in front of
the sample during the data acquisition. 
This kind of setup is actually already available on most diffraction
beam-lines. 
A new pyFAI module dealing with goniometers, along with
a couple of \textit{Jupyter Notebooks}
\cite{ipython}, proposed as supplementary materials, is presented.

The pyFAI library \cite{fv5028}, is briefly recalled then the way how to
merge multiple diffraction images acquired at different positions with this
library \cite{PyFAI_PDJ} is illustrated. 
After summarizing how calibration works in pyFAI, the new graphical user
interface is presented.
Finally, the procedure on how to calibrate the absolute position of
every single pixel in the detector when mounted on a goniometer (or on a
translation table) as a function of the goniometer motor positions, assuming
there are coupled with encoders. 

\section{The Python Fast Azimuthal Integration library (pyFAI)}

PyFAI is a Python \cite{python} library used to transform 2D diffraction images into
1D powder diffraction patterns by re-binning the pixel positions in polar
coordinates where the radial units are typically the scattering angle
$2\theta$ or the scattering vector ($q=4\pi sin(\theta)/\lambda$).
It provides in addition tools to calibrate the detector position, i.e. determine
its location in space by means of Debye-Scherrer conical rings resulting from
the intersection between the diffracted X-ray beam and the detector
surface. The rings are ellipses when the detector is planar and slightly
inclined.
The related implementation in pyFAI v0.14, release forseen mid-2017 and still
under development. 
The azimuthal integration is performed in two steps. 
The first is a pixel-wise
transformation corresponding to the image correction:

\begin{equation}
I_{cor} = \frac{signal}{normalisation}  = \frac{I_{raw} - I_{dark}}{F \times
\Omega \times P \times A } 
\end{equation}

where $I_{raw}$ is the detector's raw signal, $I_{dark}$ is the dark current
image (it may also be the background image for certain experiments), $F$ is a 
factor accounting for the flat-field correction, $\Omega$ is the solid
angle subtended by a given pixel, $P$ is the polarisation correction term
and $A$ represents the detector apparent efficiency due to the incidence angle
of the photon on the detector (for integrating detectors, high energy
photons with larger incidence angle see larger sensor thickness).
The numerator of (1), will be here after referred to as
\textit{signal}, whilst the denominator will be referred to as
\textit{normalisation}.

The second step is the re-binning of the data, which is carried out 
using a histogram of the $q$ or $2\theta$ values, weighted by the
\textit{signal}.
This gives the sum of all \textit{signals} within a ring.
A second ($q$ or $2\theta$)-histogram is calculated, weighted
by the \textit{normalization} this time, which gives the sum of all
normalised values.

The average signal over a ring is then simply the ratio of the two histograms:

\begin{equation}
<I>_{ring} = \frac{\sum\limits_{i \in ring} c_i \times signal_i}
                  {\sum\limits_{i \in ring} c_i \times normalisation_i} 
\end{equation}

In (2), $c_i$ corresponds to the fraction of a pixel area 
falling into a specific histogram bin. 
PyFAI provides multiple pixel splitting schemes that differ only by their
respective $c_i$ coefficients. 
Simple weighted histograms correspond actually to no splitting at all; in this
case $c_i$ is 1 only for pixels falling in the corresponding bin an 0 for all
the others.
  
The multiple pixel splitting schemes have already been described in
 \cite{fv5028} and can be stored as sparse matrices to accelerate the
 calculation of the histograms  \cite{kieffer_ashiotis-proc-euroscipy-2014}.

\section{Azimuthal integration of multiple frames taken at multiple geometries}

The pyFAI integration scheme of multiple images taken at varying position has
first been reported for  in  \cite{PyFAI_PDJ}. 
The procedure is conceptually similar to the integration on a single image,
except that the various histograms, all calculated over the same
grid, are summed together, i.e. \textit{signals} and, separatly, 
\textit{normalisations} from all images as follows: 

\begin{equation}
<I>_{ring} = \frac{\sum\limits_{imges} \sum\limits_{i \in ring} c_i \times
signal_i} {\sum\limits_{imges} \sum\limits_{i \in ring} c_i \times
normalization_i} 
\end{equation}

The normalization for solid angle correction $\Omega$ has to be performed
using an absolute solid angle reference system (unlike the case of single
frame integration) as different geometries may have very different
sample-to-detector distances.
Hence single image integrated intensity in multi-geometry mode is by orders of
magnitude larger than using the ``normal'' pyFAI integration methods.

\section{Calibration of the detector position}

\subsection{Principle of the calibration using a Debye-Scherrer diffraction
image}
The calibration of a detector position is performed using the Debye-Scherrer
rings collected from a reference powder called \textit{calibrant}.
The rings are extracted automatically and control points are placed at the
local maxima on the rings.
The geometry of the experiment is obtained from least-square fitting of
the $2\theta$ points.
%In this work we will call them ``rings'' even if, for planar detector,
%they are actually the conic intersections of the X-ray beam cones
%with the detector plane.
For non planar detectors (also supported by pyFAI) these ``rings'' can
be any curve.

The least-square refinement is optimizing a set of six parameters
(or seven adding the wavelength), defined around the definiton of Point
Of Normal Incidence (hereafter named \textsc{poni}, Figure \ref{poni}), which is
the orthogonal projection  of the sample position on the detector plane (or
$z=d_3=0$ when the detector is non-planar and $z$ varies from pixel to pixel).
This \textsc{poni} differs from the beam centre used in programs like
Fit2D \cite{fit2d} since the \textsc{poni} is always defined and often lies
within the detector's image, the detector gathering more photons 
when facing the sample.

\begin{figure}
\label{poni}
\begin{center}
\includegraphics[width=9cm]{images/PONI.png}
\caption{Geometry used in pyFAI.}
\end{center}
\end{figure}


The parameters to be refined are the following:
\begin{itemize}
  \item $dist$: the distance (in metre) from the sample position to the
  \textsc{poni}
  \item $poni_1$ and $poni_2$: space coordinates of the
  \textsc{poni} (in metre) within the detector plane ($z=d_3=0$) along the slow
  and the fast dimension of the detector image (1 and 2 usually refer to the row
  and the column axis, i.e. ``y, x'' respectively).
  \item $rot_1$, $rot_2$ and $rot_3$: the
  rotation angles (expressed in radians) of the detector placed at the proper
  distance from the sample, with respect to the 3 axes of the
  laboratory reference system.
  The detector is first rotated around the vertical axis ($rot_1$), then
  around the horizontal axis ($rot_2$) and in the end around the
  incoming beam direction ($rot_3$).
\end{itemize}

This parameter set describes any detector position in
space.
The drawback is that some parameters are correlated: 
\begin{itemize}
  \item \textit{dist-wavelength}: reducing the wavelength is equivalent to
  increasing the distance unless the diffraction angle $2\theta$ is actually
  large ($>30^o$). 
  It is advisable to fix one of the two variable unless the data are good
  quality and the scattering angles are large.
  \item $rot_1$-$poni_2$ and $rot_2$-$poni_1$, as small rotations can be
  interpreted as larger translations. 
  Fixing one of the two decreases the uncertainty of the other by two orders of
  magnitude.
\end{itemize}

Due to the azimuthal symmetry of the Debye-Scherrer cones, $rot_3$ 
is never refined and stays at zero unless specified differently.  
This can be used to simulate the azimuthal rotation of the
experimental setup. 
It has no effect in most cases, except for the
polarisation of the incident beam, which is the
main anisotropic contribution to the signal.

The calibration parameters are saved in text files with the ``.poni''
extension, which contains also the detector definition and the wavelength.
This file can subsequently be loaded into an \textit{azimuthal integrator}
object, ready to perform the azimuthal integration.

\subsection{Graphical user interface}

A semi-graphical calibration tool has been available as part of pyFAI
\cite{fv5028} since the origin of the project but this tool was considered too
difficult by unexperienced users (while well accepted among
the beamline staff).
Following the survey conducted among the beam-line scientists of the ESRF, a
new graphical user interface design was developed, on top of the PyQt5 library
\cite{pyqt} specifically focusing the needs of novice users.
The calibration of the experimental setup based on Debye-Scherrer rings 
occurs in five steps:
\begin{itemize}
  \item Experimental settings: select wavelength, calibrant and detector (Figure
  \ref{calib_1}),
  \item Mask: a tool to mask unwanted regions/pixels of the
  image (Figure \ref{calib_2}),
  \item Peak picking: selects rings and assign them to ring numbers (Figure
  \ref{calib_3}),
  \item Geometry fitting: optimization of the detector position (Figure
  \ref{calib_4}), 
  \item Integration: carries out 1D and 2D integration of the image (Figure
  \ref{calib_5}). 
\end{itemize}

This new graphical user interface takes advantage of the masking tools and HDF5
browsing widgets developed in the frame of the \textit{silx} \cite{silx}
project, which stream lines development efforts around data analysis.
This new interface accounts for a simpler manual peak picking, and caters for
automatic ring extraction, fitting of the gerometry and exporting of the
regrouped data.
The results are stored in \textsc{poni}-file; in
addition the list of control points used for the geometry fitting can be saved as \textsc{npt}-file.

\begin{figure}
\label{calib_1}
\begin{center}
\includegraphics[width=9cm]{images/calibration-1-settings.png}
\caption{Energy, calibrant and detector setting in pyFAI.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_2}
\begin{center}
\includegraphics[width=9cm]{images/calibration-2-mask.png}
\caption{Mask drawing tool.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_3}
\begin{center}
\includegraphics[width=9cm]{images/calibration-3-peak-picking.png}
\caption{Peak picking tool and ring assignment.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_4}
\begin{center}
\includegraphics[width=9cm]{images/calibration-4-fitting.png}
\caption{Selection of the fit parameters.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_5}
\begin{center}
\includegraphics[width=9cm]{images/calibration-5-integration-result.png}
\caption{1D/2D integration interface.}
\end{center}
\end{figure}


This new graphical user interface, althought still under development, is
already available in the development branch of pyFAI and will be distributed in the
final version of pyFAI v0.14.

\section{Calibration of a detector on a moving stage}

The calibration of the detector position on a fixed goniometer position can be
performed with pyFAI as long as at least two rings of the chosen calibrant are
present in the image and that five control points can be extracted from one
ring and at least one point from the second ring. 
Of course, more points provide a better fit but this limit may be an issue
if very small area detectors are used (i.e. the ImXPAD S10 is
as small as 80x120 pixels).

\subsection{Transformation of geometry}

This time, the difficulty is not in the calibration, but  rather in the
variety of goniometers and translation tables which may be controlled by one or multiple
motors.
%These motors are usually coupled with encoders, such as the actual position of
%the motors is known precisely.
The goniometer description implemented in pyFAI accepts an
arbitrary number of motors attached to the goniometer/translation table. 
% which may be named (must be named for more than one moving motor). 
Let $motors = (motor_1, motor_2, \ldots, motor_n)$ be such motors. 

Calibrating the goniometer consists in:
\begin{itemize}
  \item defining a set of parameters for the goniometer, of arbitrary size:
  $params = param_1, param_2, \ldots, param_m$),
  \item defining a \textit{transformation functions} $\Re$ which transforms the motor positions
  and the goniometer parmaters into the six \textsc{poni}-parameters used by
  pyFAI,
  \item optimizing the parameter set of the goniometer (\textit{params}) so that
  for any position of the motors, the detector position can be expressed as
  a \textsc{poni}-parameters set.
\end{itemize}

This \textit{tranformation function} contains hence the motor names, the
parameter names with their associated values (obtained by fitting), and returns
the six individual parameters used in \textit{pyFAI}; it can be formally
expressed as:

\begin{equation}
P_{pyFAI} = dist, poni_1, poni_2, rot_1, rot_2, rot_3 = \Re_{params}(motors)
\end{equation}


The six \textsc{poni}-parameters returned 
%contained in the \textsc{poni}-file 
are then used to
calculate the $2\theta_{exp}$ position of the peaks over all control
points.
Those $2\theta_{exp}$ are compared to
the expected $2\theta_{theo}$ values calculated from the calibrant d-spacing and
the wavelength.

$$
\Delta 2\theta = 2\theta _{exp} - 2\theta _{theo} =
arctan(\frac{r(P_{pyFAI})}{d(P_{pyFAI})}) -  2 \times
arcsin(\frac{\lambda}{2d})
$$


The average of the squares of these differences is used as a cost function
to optimise the \textit{params} using the \textit{scipy.optimize.minimize}
function from SciPy \cite{scipy}.

$$
CostFunct = \frac{ \sum\limit_{i \in cp} {(\Delta 2\theta_i)^2}} {nb(cp)} 
$$

From a computer engineering perspective, this \textit{transformation function}
should also be serialisable to disk (actually in \textsc{json}-format) to allow
its restoration from a file without having to re-perform the calibration. 
To address this constraint, the \textit{NumExpr} library \cite{numexpr} is
used, enabling the user to provide textual mathematical formulae with
an arbitrary number of degrees of freedom for the goniometer and as many parameters
as needed.

The definition of this function is simply the instantiation of the
\textit{pyFAI.goniometer.GeometryTransformation} class, with a list of
motor and parameter names as well as a set of six formulae, one for each of
the \textsc{poni}-parameters.
This may appear complicated and is best explained by the two following examples.

\subsection{A simple example: the translation table}

At the  ESRF, the protein crystallography beam-lines use large pixel detectors
(typically Pilatus 6M from Dectris) placed on a translation stage which allows
collecting the data at the optimal distance: shorter sample-to-detector
distances to explore the region for high-$q$ 
or longer distances for better Bragg peak separation.

The ``MX-calibrate'' tool of PyFAI is available for calibrating many images
taken at various distances.
This can also be interpreted in terms of a goniometer setup (actually a
translation table) where the sample-to-detector distance is modelled as a
simple linear function of the translation table position:

\begin{verbatim}
from pyFAI.goniometer import GeometryTransformation
gt = GeometryTransformation(param_names = ["dist_offset", "dist_scale", 
                                        "poni1", "poni2", "rot1", "rot2"],
                            pos_names = ["position"],
                            dist_expr="position * dist_scale + dist_offset", 
                            poni1_expr="poni1",
                            poni2_expr="poni2", 
                            rot1_expr="rot1", 
                            rot2_expr="rot2", 
                            rot3_expr="0.0")
\end{verbatim}
 
In the example above, we chose to use six parameters for the goniometer
geometry, most of them being exactly the same as those of pyFAI: 
$poni_1$, $poni_2$, $rot_1$
and $rot_2$. 
$rot_3$ is forced to zero while the distance is defined as a 
linear function of the motor position. 
This makes actually six degrees of freedom  (\textit{dof}) to be refined.
Motor names should be declared as a list and assigned to \textit{pos names}. 
If no motor names are provided, a single motor  configuration (called $pos$)
is assumed.

The Jupyter notebook \cite{ipython} in a Supplementary Material  file called
``TTcalibration'', presents the usage of the \textit{transformation function}
class together with the translation table refinement. 
Initially, this set of data is calibrated using the ``MX-calibrate'' tool
that extracts automatically the control points from images taken at
ESRF MX beam-lines from the metadata written in the image headers, 
thus a set of control points is available prior to processing the data.
The translation table is calibrated using all control points
and this \textit{transformation function}.
As a result, all images have been integrated azimuthally.
The Figure \ref{id29} is a zoom on the two first Bragg peaks of CeO$_2$. 
The blue curve correspond to this initial model refined; the two peaks look
``doubled'' indicating a poor modelling of the geometry.

\begin{figure}
\label{id29}
\begin{center}
\includegraphics[width=9cm]{images/TranslationTable.png}
\caption{Powder diffraction profile obtained from seven images acquired
at various distances from 15 to 45 centimeters. 
The translation table position is combined with 6 (resp. 8) parameter model
fitted where the $dist$ (resp. $dist$, $poni_1$ and $poni_2$) depends on the
table position.}
\end{center}
\end{figure}

 
To address this poor modelling, another \textit{transformation function} is
defined, with a couple of additional $dof$ on the \textsc{poni} position
(linear dependency of the \textsc{poni} with the table position).
After everything is re-fitted and re-integrated, the peaks of the orange curve
in Figure \ref{id29} are much sharper, and the cost function is about $5\times$
smaller. 

This example shows that the \textsc{poni} is moving on the detector
plane by one millimetre per meter (1\textperthousand) horizontally and 
4 \textperthousand vertically.
This ``large'' vertical deviation has been confirmed by the beam-line staff and
is related to the focussing mirror placed just before the sample, causing the
beam to be no more horizontal.
Once everything is fitted, the quality of the geometry obtained is perfectly
suited to powder diffraction experiments for any detector position. The
$Notebook$ exposes in addition how to re-extract all control points, but it
does not improve the fit. 
  
\subsection{A more realistic example: a single axis goniometer}

Probably the main application of this work is to place a small size detector
on a goniometer $2\theta$ arm. 

When the detector arm is moving verically, a simple \textit{geometry
transformation} is defined with $rot_2$ (in radians) as a
linear transformation of the motor position, $pos$, (measured in degrees).
The scale parameter, $scale = \pi / 180$, is used to convert degrees to radians, 
assuming a neglectable offset.
The other parameters $dist$, $poni_1$, $poni_2$ and $rot_1$ are directly mapped
to pyFAI's parameters.
As previously, $rot_3$ is kept fix at zero.

\begin{verbatim}
from pyFAI.goniometer import GeometryTransformation
goniotrans = GeometryTransformation(param_names = ["dist", "poni1", "poni2", "rot1",
                                                   "rot2_offset", "rot2_scale"],
                                    dist_expr="dist", 
                                    poni1_expr="poni1",
                                    poni2_expr="poni2", 
                                    rot1_expr="rot1", 
                                    rot2_expr="rot2_scale * pos + rot2_offset", 
                                    rot3_expr="0.0")
\end{verbatim}


This example is also available as a \textit{Jupyter
Notebook} in Supplementary Material file called ``Multi120Pilatus100k'', and
the workflow used is depicted in Figure \ref{workflow}.
This experiment has been performed using a single module (100k) Pilatus
detector which is mounted on a vertically moving $2\theta$ arm, varying 
from 5 to 65 degrees by half degree step on the ROBL beam-line (ESRF BM20,
German CRG beam-line).
So 121 LaB$_6$ calibrant images have been acquired.
Due to the small size of the detector (487x197 pixels),
some of the images present no ring at all (especially at low $2\theta$ angle),
most have one ring and only a few images display 2 rings.

\begin{figure}
\label{workflow}
\begin{center}
\includegraphics[width=9cm]{images/workflow.png}
\caption{Workflow used to calibrate a set of 121 Pilatus 100k images one a
moving $2\theta$ arm and detailed in the \textit{Jupyter Notebook} of 
Supplementary Material.}
\end{center}
\end{figure}

The first images presenting two rings correspond to goniometer positions above
30 degrees. 
Four images, taken at goniometer angles of 31.5, 33 and 35 and 35.5
degrees have been manually calibrated using the \textit{pyFAI-calib} tool
presented in the previous section.
This manual calibration is rather tedious and unstable due to the small
curvature of the rings on the detector image. 
The rotation along axis 1 of the detector ($rot_1=0$) has been kept fixed to
guarantee some consistency between the four images.

An initial simple model with a set of parameters where $rot_2$ is equal to the
goniometer angle has first lead to convergence with some constraints and
bounds (see Supplementary Materials).
In a second step, twenty images in the neighbourhood of the first ones have been
added to the model, their peaks extracted according to the initial model and the
model refined using the control points from the twenty images.
Then, all other images have been added to the model, and additional control
points have been automatically extracted from all images according to the
previous geometry model.
After all constraints and bounds have been removed, the model has been refined
again and used to generate a \textit{MultiGeometry} object, able to integrate many
images together.
After integration of all 121 images, the powder diffraction pattern displayed
in Figure \ref{bm20}, orange curve is obtained.
All peaks of the curve appear at the correct scattering angle but
the first ones looks exceedingly broad. 

\begin{figure}
\label{bm20}
\begin{center}
\includegraphics[width=9cm]{images/gonio.png}
\caption{Powder diffraction pattern obtained from 121 images acquired
at goniometer angles ranging from 5 to 65 degrees. On the right-hand size,
a close-up view on the first peak following a simple model (6 degrees of
freedom, in orange) or according a model where two parameters are
functions of the goniometer position (7 degrees of freedom, in blue).}
\end{center}
\end{figure}


This broadening is confirmed by looking at the first ring's image, where the
goniometer angle was set to 10 degrees (Figure \ref{bm20_10}).
The expected position of the ring (dashed red line) does not correspond
properly to the actual ring (yellow on the image). The control points extracted
are plotted in blue.

\begin{figure}
\label{bm20_10}
\begin{center}
\includegraphics[width=9cm]{images/gonio_10.png}
\caption{Diffraction image taken with the goniometer arm at 10 degrees.
The control points are in blue and the expected ring of the simple model
($rot2=f(pos)$) is the dashed red line. This highlights the need for $rot_1$
to depend on the goniometer position.}
\end{center}
\end{figure}

Another model was suggested, allowing also the $rot_1$ to depend linearly on the
goniometer position. 
After refinement, the cost function dropped by a factor two and
the low angle peaks were sharpen (blue curve in Figure \ref{bm20}). 

This parameter set was saved and allowed a few compounds to be analysed and
compared to the same pattern recorded via a moving point detector. 
The signal/noise ratio is better with an acquisition time of an order
of magnitude shorter than previously, thus opening new prospects for
the ROBL beamline.

A third example of goniometer calibration is available in the Supplementary
Material. It corresponds to the calibration of an ImXPAD detector composed
of 8 stripes of 7 modules, many of which are defective.
This detector is mounted on the goniometer arm at the D2AM beam-line, French CRG
at the ESRF synchrotron. 
This example is conceptually the same as the the one from the ROBL beam-line,
with a few differences:
\begin{itemize}
  \item the detector being larger, the calculation time is
longer,
  \item the mask needs some extra care to remove the hot pixels
  \item the detector is mounted rotated of 90 degrees on the arm, this is why
  $rot_3=\pi/2$
\end{itemize}

\section{Outlook}

The goniometer description in this work can be adapted to
many types of simple goniometer.
The \textit{TransformationFunction} class presented in the notebook may be extended
in the future to use \textit{libhkl} \cite{libhkl} which contains already many
diffractometer geometries with their associated rotation matrices. 
This is already possible now but it does not yet allow the saving into and
restoring from a file. 

By moving the detector in front of the sample, one can fill up the
gaps which exists in pixel detectors.
Those gaps are known to be responsible for glitches
when acquiring PDF data with high energy photons due to the
polarization of the synchrotron beam, causing large anisotropy in the
diffracted signal. 
A (couple of) simple move(s) of a few millimeters could be enough to
solve this issue.

Different generations of pixel detectors have seen their pixel size
shrink:
from $172 \mu m$ for the Pilatus, $130 \mu m$ for ImXPAD, $75 \mu m$ for the
Eiger and $55 \mu m$ for Medipix-based chips \ldots, and probably less for
future detectors.
As the resolution of the powder diffraction diagram obtained is limited by the
pixel size (and the distance of the detector), this shrinkage of pixel-size
leads naturally to better resolved powder diffraction patterns. 
Unfortunately, to keep the surface of the detector constant, one would need
to multiply the number of pixels by the square of this value, and the
associated infrastructure for read-out and data-transfer. 
Moving the detector in front of the sample offers a flexibility which
partially removes this limitation.

\section{Conclusion}

The new graphical user interface for pyFAI has been developed to ease the
calibration of the experimental setup with fixed detector, especially for first
time users.
The concept of calibration of the detector position has been extended to fit
the detector position with the motion of a goniometer.   
Once a few position of the goniometer have been calibrated, a model can
be fitted to determine the detector position at any goniometer position. 
By acquiring multiple images a various positions, images can be
integrated together to provide a high-$q$ powder diffraction pattern of
quality equivalent to the one acquired with a much larger detector. 
 
\ack{Acknowledgements}

We would like to thank all ESRF beam-line teams for supporting the
pyFAI development, and especially David Flot from the MX-group who provided the
data of the translation table and the two CRG beamlines BM02 (D2AM) and BM20
(ROBL) for the goniometer data. 
They gracefully provided beam-time and test-data to allow debugging this 
goniometer optimization tool.
We would also like to thank the French CNRS for financing the IR-DRX project
in 2015 and 2016 which acted as a catalyzer on the goniometer refinement,
and the other participants to the project, especially Serge Cohen from the
Ipanema institute, the DiffAbs beamline and Frédéric-Emmanuel Picca from
Synchrotron Soleil.
In the instrumentation division (ISDD) from ESRF  we would like to thank V. A.
Solé, head of data analysis unit and leader of the \textit{silx} project, and all our
colleagues from the silx project: Thomas Vincent, Henri Payno, Damien Naudet and
Pierre Knobel for their support and ideas. 
Finally we ackowledge Claudio Ferrero for the carefull proof-reading of the
manuscript. 

\bibliographystyle{iucr}
\bibliography{biblio}


\end{document}
