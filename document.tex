%------------------------------------------------------------------------------
% Template file for the submission of papers to IUCr journals in LaTeX2e
% using the iucr document class
% Copyright 1999-2003 International Union of Crystallography
% Version 1.2 (11 December 2002)
%------------------------------------------------------------------------------
%
\documentclass[preprint, pdf]{iucr}              % DO NOT DELETE THIS LINE
                   \def\href#1{\relax}\let\foo\caption
\ifPDF
  \RequirePackage{hyperref}
  \PassOptionsToPackage{pdftex,bookmarksopen,bookmarksnumbered}{hyperref}
  \voffset=-0.5in
\fi
\let\caption\foo

\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage{eps2pdf}

 \paperprodcode{a000000}      % Replace with production code if known
 \paperref{xx9999}            % Replace xx9999 with reference code if known
 \papertype{IU}               % Indicate type of article
 \paperlang{english}          % Can be english, french, german or russian
 \journalcode{J}             % Indicate the journal to which submitted
 \journalyr{2017}
 \journalreceived{\relax}
 \journalaccepted{\relax}
 \journalonline{\relax}

\begin{document}                  % DO NOT DELETE THIS LINE

\title{Calibration of experimental setups with {pyFAI}: New tools for still
detector and moving detectors}
\shorttitle{Calibration tools in pyFAI w/wo goniometer}

 \author[a]{V.}{Valls}
 \cauthor[a]{J.}{Kieffer}{jerome.kieffer@esrf.eu}
 
 
 \aff[a]{ESRF, The European Synchrotron, CS40220, 38043 \city{Grenoble}
 Cedex 9, \country{France}}
 \shortauthor{Valls and Kieffer}


\keyword{Powder diffraction}
\keyword{translation table}
\keyword{goniometer}
\keyword{geometry calibration}



\maketitle                        % DO NOT DELETE THIS LINE

\begin{synopsis}
New tools to calibrate different types of scattering experiments : static
detectors or moving detectors.
\end{synopsis}

\begin{abstract}


This work presents new calibration tools in the pyFAI
suite for processing scattering experiments acquired with area detectors:
a new graphical user interface for calibrating the detector position in a  
scattering experiment performed with a fixed, large area detector as well as 
a library to be used in \textit{Jupyter notebooks} for calibrating the motion
of a detector on a goniometer arm (or any other moving table) to perform
diffraction experiments.
\end{abstract}


\section{Introduction}

According to an internal survey performed among the beam-line scientists at
the European Synchrotron (ESRF) in 2016, the factor limiting the users'
productivity at diffraction beam-lines is the calibration of the experimental
setup before accessing to the raw data for their reduction. 
The calibration issue is currently worked around by providing users with the
proper geometry description or even the reduced data, but this prevents the
re-processing at home institutes and also the re-interpretation of data which
is needed as a part of the open data initiative.

At X-ray facilities like synchrotons, large area detectors are 
preferred for gathering a maximum number of photons in
scattering experiments (powder diffraction, small angle
scattering, \ldots).
% The still position of the detector during the acquisition, makes also
%easier the data-reduction step.
Using a fixed position setup combined with the speed of modern detectors (up
to a few kHz) the data acquisition in kinetic mode is easily performed to 
follow chemical reactions or other physical processes \cite{id15, id31}.
Even with fixed geometries, determining the detector's position is
still an issue for a majority of users. 
Hence, a new graphical user interface has been developed for pyFAI, focusing
on the user's experience to grant them autonomy in data analysis, once they
are back in their home institutes.

Differently from large facilities, lab source diffractometers
are commonly equipped with (small) area detectors mounted on moveable goniometer
arms for powder diffraction (for example, the Rigaku HyPix-3000 detector),
%The larger number of pixels trades-of the resolution for speed.
Whereas detectors at synchrotrons are often mounted on goniometer or
translation tables, those degrees of freedom are rarely used for data
acquisition.
One counter-example is reported in \cite{Gao:kc5032}, where the beamline
is equipped with a moving strip-detector, the Mythen detector from Dectris,
which is not an area detector.

%On the opposite, moving detector setups are rarely
%used at synchrotrons for the data acquisition itself, even if most of the
% detectors are mounted on a moving table or on a goniometer. 



%High-Q diffraction signal acquisition is needed  for
Pair Distribution Function (\textsc{pdf}) analysis requires very large
detectors and higher energies to be able to cover the needed high $q$-range in
one single frame \cite{Chupas:wf5000}.
When speed is not critical, \textsc{pdf} experiments could be performed
with smaller detectors mounted on a motorized arm, and moved in front of
the sample during the data acquisition. 
This kind of setup is actually already available on most diffraction
beam-lines. 
A new pyFAI module dealing with goniometers, along with
a couple of \textit{Jupyter Notebooks}
\cite{ipython}, proposed as supplementary materials, is presented.

The pyFAI library \cite{fv5028}, is briefly recalled then the way how to
merge multiple diffraction images acquired at different positions with this
library \cite{PyFAI_PDJ} is illustrated. 
After summarizing how calibration works in pyFAI, the new graphical user
interface is presented.
Finally, the procedure on how to calibrate the absolute position of
every single pixel in the detector when mounted on a goniometer (or on a
translation table) as a function of the goniometer motor positions, assuming
there are coupled with encoders. 

\section{The Python Fast Azimuthal Integration library (pyFAI)}

PyFAI is a Python \cite{python} library used to transform 2D diffraction images into
1D powder diffraction patterns by re-binning the pixel positions in polar
coordinates where the radial units are typically the scattering angle
$2\theta$ or the scattering vector ($q=4\pi sin(\theta)/\lambda$).
It provides in addition tools to calibrate the detector position, i.e. determine
its location in space by means of Debye-Scherrer conical rings resulting from
the intersection between the diffracted X-ray beam and the detector
surface. The rings are ellipses when the detector is planar and slightly
inclined.
The related implementation in pyFAI v0.14, release forseen mid-2017 and still
under development. 
The azimuthal integration is performed in two steps. 
The first is a pixel-wise
transformation corresponding to the image correction:

\begin{equation}
I_{cor} = \frac{signal}{normalisation}  = \frac{I_{raw} - I_{dark}}{F \times
\Omega \times P \times A } 
\end{equation}

where $I_{raw}$ is the detector's raw signal, $I_{dark}$ is the dark current
image (it may also be the background image for certain experiments), $F$ is a 
factor accounting for the flat-field correction, $\Omega$ is the solid
angle subtended by a given pixel, $P$ is the polarisation correction term
and $A$ represents the detector apparent efficiency due to the incidence angle
of the photon on the detector (for integrating detectors, high energy
photons with larger incidence angle see larger sensor thickness).
The numerator of (1), will be here after referred to as
\textit{signal}, whilst the denominator will be referred to as
\textit{normalisation}.

The second step is the re-binning of the data, which is carried out 
using a histogram of the $q$ or $2\theta$ values, weighted by the
\textit{signal}.
This gives the sum of all \textit{signals} within a ring.
A second ($q$ or $2\theta$)-histogram is calculated, weighted
by the \textit{normalization} this time, which gives the sum of all
normalised values.

The average signal over a ring is then simply the ratio of the two histograms:

\begin{equation}
<I>_{ring} = \frac{\sum\limits_{i \in ring} c_i \times signal_i}
                  {\sum\limits_{i \in ring} c_i \times normalisation_i} 
\end{equation}

In (2), $c_i$ corresponds to the fraction of a pixel area 
falling into a specific histogram bin. 
PyFAI provides multiple pixel splitting schemes that differ only by their
respective $c_i$ coefficients. 
Simple weighted histograms correspond actually to no splitting at all; in this
case $c_i$ is 1 only for pixels falling in the corresponding bin an 0 for all
the others.
  
The multiple pixel splitting schemes have already been described in
 \cite{fv5028} and can be stored as sparse matrices to accelerate the
 calculation of the histograms  \cite{kieffer_ashiotis-proc-euroscipy-2014}.

\section{Azimuthal integration of multiple frames taken at multiple geometries}

The pyFAI integration scheme of multiple images taken at varying position has
first been reported for  in  \cite{PyFAI_PDJ}. 
The procedure is conceptually similar to the integration on a single image,
except that the various histograms, all calculated over the same
grid, are summed together, i.e. \textit{signals} and, separatly, 
\textit{normalisations} from all images as follows: 

\begin{equation}
<I>_{ring} = \frac{\sum\limits_{imges} \sum\limits_{i \in ring} c_i \times
signal_i} {\sum\limits_{imges} \sum\limits_{i \in ring} c_i \times
normalization_i} 
\end{equation}

The normalization for solid angle correction $\Omega$ has to be performed
using an absolute solid angle reference system (unlike the case of single
frame integration) as different geometries may have very different
sample-to-detector distances.
Hence single image integrated intensity in multi-geometry mode is by orders of
magnitude larger than using the ``normal'' pyFAI integration methods.

\section{Calibration of the detector position}

\subsection{Principle of the calibration using a Debye-Scherrer diffraction
image}
The calibration of a detector position is performed using the Debye-Scherrer
rings collected from a reference powder called \textit{calibrant}.
The rings are extracted automatically and control points are placed at the
local maxima on the rings.
The geometry of the experiment is obtained from least-square fitting of
the $2\theta$ points.
%In this work we will call them ``rings'' even if, for planar detector,
%they are actually the conic intersections of the X-ray beam cones
%with the detector plane.
For non planar detectors (also supported by pyFAI) these ``rings'' can
be any curve.

The least-square refinement is optimizing a set of six parameters
(or seven adding the wavelength), defined around the definiton of Point
Of Normal Incidence (hereafter named \textsc{poni}, Figure \ref{poni}), which is
the orthogonal projection  of the sample position on the detector plane (or
$z=d_3=0$ when the detector is non-planar and $z$ varies from pixel to pixel).
This \textsc{poni} differs from the beam centre used in programs like
Fit2D \cite{fit2d} since the \textsc{poni} is always defined and often lies
within the detector's image, the detector gathering more photons 
when facing the sample.

\begin{figure}
\label{poni}
\begin{center}
\includegraphics[width=9cm]{images/PONI.png}
\caption{Geometry used in pyFAI.}
\end{center}
\end{figure}


The parameters to be refined are the following:
\begin{itemize}
  \item $dist$: the distance (in metre) from the sample position to the
  \textsc{poni}
  \item $poni_1$ and $poni_2$: space coordinates of the
  \textsc{poni} (in metre) within the detector plane ($z=d_3=0$) along the slow
  and the fast dimension of the detector image (1 and 2 usually refer to the row
  and the column axis, i.e. ``y, x'' respectively).
  \item $rot_1$, $rot_2$ and $rot_3$: the
  rotation angles (expressed in radians) of the detector placed at the proper
  distance from the sample, with respect to the 3 axes of the
  laboratory reference system.
  The detector is first rotated around the vertical axis ($rot_1$), then
  around the horizontal axis ($rot_2$) and in the end around the
  incoming beam direction ($rot_3$).
\end{itemize}

This parameter set describes any detector position in
space.
The drawback is that some parameters are correlated: 
\begin{itemize}
  \item \textit{dist-wavelength}: reducing the wavelength is equivalent to
  increasing the distance unless the diffraction angle $2\theta$ is actually
  large ($>30^o$). 
  It is advisable to fix one of the two variable unless the data are good
  quality and the scattering angles are large.
  \item $rot_1$-$poni_2$ and $rot_2$-$poni_1$, as small rotations can be
  interpreted as larger translations. 
  Fixing one of the two decreases the uncertainty of the other by two orders of
  magnitude.
\end{itemize}

Due to the azimuthal symmetry of the Debye-Scherrer cones, $rot_3$ 
is never refined and stays at zero unless specified differently.  
This can be used to simulate the azimuthal rotation of the
experimental setup. 
It has no effect in most cases, except for the
polarisation of the incident beam, which is the
main anisotropic contribution to the signal.

The calibration parameters are saved in text files with the ``.poni''
extension, which contains also the detector definition and the wavelength.
This file can subsequently be loaded into an \textit{azimuthal integrator}
object, ready to perform the azimuthal integration.

\subsection{Graphical user interface}

A semi-graphical calibration tool has been available as part of pyFAI
\cite{fv5028} since the origin of the project but this tool was considered too
difficult by unexperienced users (while well accepted among
the beamline staff).
Following the survey conducted among the beam-line scientists of the ESRF, a
new graphical user interface design was developed, on top of the PyQt5 library
\cite{pyqt} specifically focusing the needs of novice users.
The calibration of the experimental setup based on Debye-Scherrer rings 
occurs in five steps:
\begin{itemize}
  \item Experimental settings: select wavelength, calibrant and detector (Figure
  \ref{calib_1}),
  \item Mask: a tool to mask unwanted regions/pixels of the
  image (Figure \ref{calib_2}),
  \item Peak picking: selects rings and assign them to ring numbers (Figure
  \ref{calib_3}),
  \item Geometry fitting: optimization of the detector position (Figure
  \ref{calib_4}), 
  \item Integration: carries out 1D and 2D integration of the image (Figure
  \ref{calib_5}). 
\end{itemize}

This new graphical user interface takes advantage of the masking tools and HDF5
browsing widgets developed in the frame of the \textit{silx} \cite{silx}
project, which stream lines development efforts around data analysis.
This new interface accounts for a simpler manual peak picking, and caters for
automatic ring extraction, fitting of the gerometry and exporting of the
regrouped data.
The results are stored in \textsc{poni}-file; in
addition the list of control points used for the geometry fitting can be saved as \textsc{npt}-file.

\begin{figure}
\label{calib_1}
\begin{center}
\includegraphics[width=9cm]{images/calibration-1-settings.png}
\caption{Energy, calibrant and detector setting in pyFAI.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_2}
\begin{center}
\includegraphics[width=9cm]{images/calibration-2-mask.png}
\caption{Mask drawing tool.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_3}
\begin{center}
\includegraphics[width=9cm]{images/calibration-3-peak-picking.png}
\caption{Peak picking tool and ring assignment.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_4}
\begin{center}
\includegraphics[width=9cm]{images/calibration-4-fitting.png}
\caption{Selection of the fit parameters.}
\end{center}
\end{figure}
\begin{figure}
\label{calib_5}
\begin{center}
\includegraphics[width=9cm]{images/calibration-5-integration-result.png}
\caption{1D/2D integration interface.}
\end{center}
\end{figure}


This new graphical user interface, althought still under development, is
already available in the development branch of pyFAI and will be distributed in the
final version of pyFAI v0.14.

\section{Calibration of a detector on a moving stage}

The calibration of the detector position on a fixed goniometer position can be
performed with pyFAI as long as at least two rings of the chosen calibrant are
present in the image and that five control points can be extracted from one
ring and at least one point from the second ring. 
Of course, more points provide a better fit but this limit may be an issue
if very small area detectors are used (i.e. the ImXPAD S10 is
as small as 80x120 pixels).

\subsection{Transformation of geometry}

This time, the difficulty is not in the calibration, but  rather in the
variety of goniometers and translation tables which may be controlled by one or multiple
motors.
%These motors are usually coupled with encoders, such as the actual position of
%the motors is known precisely.
The goniometer description implemented in pyFAI accepts an
arbitrary number of motors attached to the goniometer/translation table. 
% which may be named (must be named for more than one moving motor). 
Let $motors = (motor_1, motor_2, \ldots, motor_n)$ be such motors. 

Calibrating the goniometer consists in:
\begin{itemize}
  \item defining a set of parameters for the goniometer, of arbitrary size:
  $params = param_1, param_2, \ldots, param_m$),
  \item defining a \textit{transformation functions} $\Re$ which transforms the motor positions
  and the goniometer parmaters into the six \textsc{poni}-parameters used by
  pyFAI,
  \item optimizing the parameter set of the goniometer (\textit{params}) so that
  for any position of the motors, the detector position is properly
  defined.
\end{itemize}

This can be expressed as:
$$
P_{pyFAI} = dist, poni_1, poni_2, rot_1, rot_2, rot_3 = \Re_{params}(motors)
$$

The six \textsc{poni}-parameters returned 
%contained in the \textsc{poni}-file 
are then used to
calculate the $2\theta_{exp}$ position of the peaks over all control
points.
Those $2\theta_{exp}$ are compared to
the expected $2\theta_{theo}$ values calculated from the calibrant d-spacing and
the wavelength.

$$
\Delta 2\theta = 2\theta _{exp} - 2\theta _{theo} =
arctan(\frac{r(P_{pyFAI})}{d(P_{pyFAI})}) -  2 \times
arcsin(\frac{\lambda}{2d})
$$


The average of the square of these differences is used as a cost function
and optimises the \textit{params} using the \textit{scipy.optimize.minimize}
function from SciPy \cite{scipy}.

$$
CostFunct = \frac{ \sum\limit_{i \in cp} {(\Delta 2\theta_i)^2}} {nb(cp)} 
$$


This \textit{tranformation function} contains hence the motor names, the
parameters names with their associated values (after fitting), and the six
functions, one for each of the six parameters used in \textit{pyFAI}.

From a computer engineering perspective, it should also be serializable to 
disk (in \textsc{json}-format) to allow its restoration from a file without
having to re-perform the calibration. 
To address this constrain, the NumExpr library \cite{numexpr} is
used, allowing the user to provide mathematical formula as text with an
arbitrary number of degrees of freedom for the goniometer and as many parameters
as needed.

The definition of this function is simply the instantiation of the
\textit{pyFAI.goniometer.GeometryTransformation} class, with a list of
motor names, parameter names and a set of six formula, one for each of the six parameters. 
This may appear complicated and is best explained by the two coming examples.

\subsection{A simple example: the translation table}

At ESRF, protein crystallography beam-lines use large pixel-detectors (typically
Pilatus 6M from Dectris) placed on a translation stage which allows to collect
the data at the optimal distance: shorter detector distance for high-$q$ and
small inter-reticular distances or longer distances for best spot separation.

PyFAI has the ``MX-calibrate'' tool available for calibrating many images taken
at various distances but this can be addressed as a goniometer setup where the
sample-detector distance can be modeled as a simple linear function of the table
position:

\begin{verbatim}
from pyFAI.goniometer import GeometryTransformation
gt = GeometryTransformation(param_names = ["dist_offset", "dist_scale", 
                                        "poni1", "poni2", "rot1", "rot2"],
                            pos_names = ["position"],
                            dist_expr="position * dist_scale + dist_offset", 
                            poni1_expr="poni1",
                            poni2_expr="poni2", 
                            rot1_expr="rot1", 
                            rot2_expr="rot2", 
                            rot3_expr="0.0")
\end{verbatim}
 
In this example we chose to use 6 parameters for the goniometer
geometry, most of them being exactly the same as the one of pyFAI: 
$poni_1$, $poni_2$, $rot_1$
and $rot_2$. 
$rot_3$ is forced to zero while the distance is defined a
linear function of the motor position. 
This makes actually six degrees of freedom  (\textit{dof}) to be refined.
Motor names should be declared as a list and assigned to \textit{pos names}. 
If no motor names are provided, a single motor  configuration (called $pos$)
is assumed.

The Jupyter notebook \cite{ipython} in supplementary materials file called
``TTcalibration'' presents the usage of this \textit{transformation function}
class together with the translation table refinement. 
Initially this set of data has been calibrated using the ``MX-calibrate'' tool
which extracts automatically the control points from images taken at ESRF-MX
beam-lines from the metadata written in the header of images, so a good set
of control point has been available prior to the processing described. 
The translation table has been calibrated a first time with all control points
and this \textit{transformation function} subsequently, all images have been
integrated azimuthally (Figure \ref{id29}, blue curve). 
The image is a zoom on the two first peaks which looks ``doubled'' indicating a
poor modeling of the geometry.

\begin{figure}
\label{id29}
\begin{center}
\includegraphics[width=9cm]{images/TranslationTable.png}
\caption{Powder diffraction profile obtained from seven images acquired
at various distances from 15 to 45 centimeters. 
The translation table position is combined with 6 (resp. 8) parameter model
fitted where the $dist$ (resp. $dist$, $poni_1$ and $poni_2$) depends on the
table position.}
\end{center}
\end{figure}

 
Another \textit{transformation function} has been defined, allowing in
addition a linear dependency of the \textsc{poni} position with the translation
table position, and everything was re-fitted (Figure \ref{id29}, orange curve).
The peaks are much sharper, and the cost function is about
$5\times$ smaller.
The cost function used is the average over all control points
of the deviation of the $2\theta$ angle (in radians) from theoretical value,
squared.

This example shows the \textsc{poni} is moving on the detector
plane by one millimeter per meter horizontally and four vertically.
This ``large'' vertical deviation has been confirmed by the beam-line staff and
is related to last focusing mirror, just before the sample, making the beam no
more horizontal.
Once everything is fitted, the quality of the geometry obtained is perfectly
suited for powder diffraction experiment for any detector position.
  
\subsection{A more realistic example: a single axis goniometer}

Probably the main application of this work is to place a limited size detector
on a goniometer $2\theta$ arm. 

When the detector arm is moving verically, a simple \textit{geometry
transformation} has been defined with $rot_2$ (defined in radians) as a
linear transformation of the motor position, $pos$, (measured in degrees).
The scale parameter, $scale = \pi / 180$, is used to convert degrees to radians, 
assuming a neglectable offset.
The other parameters $dist$, $poni_1$, $poni_2$ and $rot_1$ are directly mapped
to pyFAI's parameters.
As previously, $rot_3$ is kept fix at zero.

\begin{verbatim}
from pyFAI.goniometer import GeometryTransformation
goniotrans = GeometryTransformation(param_names = ["dist", "poni1", "poni2", "rot1",
                                                   "rot2_offset", "rot2_scale"],
                                    dist_expr="dist", 
                                    poni1_expr="poni1",
                                    poni2_expr="poni2", 
                                    rot1_expr="rot1", 
                                    rot2_expr="rot2_scale * pos + rot2_offset", 
                                    rot3_expr="0.0")
\end{verbatim}


This second example is also available as a \textit{Jupyter
Notebook} in supplementary material file called ``Multi120Pilatus100k'', and
the workflow used is depicted in Figure \ref{workflow}.
This experiment has been performed using a single Pilatus module (100k)
detector which is mounted on the moving $2\theta$ arm, varying 
from 5 to 65 degrees per half degree step.

 
So one hundred and twenty one images of LaB$_6$ calibrant has been acquired on
the ROBL beam-line (ESRF BM20, German CRG beam-line).
Due to the small size of the detector (487x197 pixels),
some of the images have no ring at all, most have one ring and only few images
have 2 rings.

\begin{figure}
\label{workflow}
\begin{center}
\includegraphics[width=9cm]{images/workflow.png}
\caption{Workflow used to calibrate a set of 121 Pilatus 100k images one a
moving $2\theta$ arm and detailed in the \textit{Jupyter Notebook} in
supplementary materials.}
\end{center}
\end{figure}

 

The first images with two rings correspond to the rings of the second group
of LaB$_6$ and lay above angles of 30 degrees.
Four images, taken at 31.5, 33 and 35 and 35.5 degrees have been manually
calibrated using the \textit{pyFAI-calib} tool presented in the previous
section.
This manual calibration is rather tedious and unstable due to the small size of
the detector. 
The rotation along axis 1 of the detector ($rot_1=0$) has been fixed to have
some consistency between the four images.

An initial simple model with a set of parameters where $rot_2$ is equal to the
goniometer angle has first been converged, with some constrains and
bounds (see supplementary materials).
In a second step, twenty images of the neighbourhood of the first ones have been
added to the model; their peak extracted according to the initial model and the model
refined with the control points from twenty images.
Then all other images have been added to the model, and control
points were automatically extracted from all images according to the
previous model of geometry.
After all constrains and bounds have been removed, the model was refined again
and used to generate a \textit{MultiGeometry} object, able to integrate many
images together.
After integration of all 121 images, the powder diffraction pattern displayed
in Figure \ref{bm20}, orange curve is obtained.
All peaks of the curve appear at the correct scattering angle but
the first ones looks too small and too broad. 

\begin{figure}
\label{bm20}
\begin{center}
\includegraphics[width=9cm]{images/gonio.png}
\caption{Powder diffraction pattern obtained from 121 images acquired
at goniometer angles spaced from 5 to 65 degrees. On the right-hand size,
close-up view on the first peak with a simple model (6 degrees of freedom,
in orange) or with an model where two parameters are function of the goniometer
position (7 degrees of freedom, in blue).}
\end{center}
\end{figure}


This broadening is confirmed by looking at the first ring's image, where the
goniometer was at 10 degrees, in Figure \ref{bm20_10}.
The expected position of the ring, in dashed red line, does not correspond
properly with the ring in yellow. The control points extracted are plotted in
blue.

\begin{figure}
\label{bm20_10}
\begin{center}
\includegraphics[width=9cm]{images/gonio_10.png}
\caption{Diffraction image taken at 10 degree of the goniometer arm, with the
control points in blue and the expected ring of the simple model ($rot2=f(pos)$)
in dashed red line. This highlights the need for $rot_1$ to depend on the
goniometer position.}
\end{center}
\end{figure}

Another model was suggested, allowing also the $rot_1$ to depend linearly on the
goniometer position. 
After refinement, the cost function dropped by a factor two and
the low angle peaks were sharpen (Figure \ref{bm20} curve in blue). 

This parameter set was saved and allowed a few compounds to been analyzed and
compared to the same pattern recorded with a moving point detector. 
The Signal/Noise ratio was both better with an acquisition times an order
of magnitude faster than previously, opening new perspectives for the ROBL
beamline.

\section{Outlook}

The goniometer description which is described in this work can be adapted to
many type of simple goniometer.
The \textit{TransformationFunction} class presented in the notebook may be extended
in the future to use \textit{libhkl}\cite{picca} which contains already many
diffractometer geometries with their associated rotation matrices. 
This is already possible now but it do not yet allow the saving and
restoration from file. 

By moving the detector in front of the sample, one can fill up the
gaps which exists in pixel detectors.
Those gaps are known to be responsible for glitches
when acquiring PDF data with high energy photons due to the
polarization of the synchrotron beam, causing large anisotropy in the
diffracted signal. 
A simple move of a couple of millimeters could be enough to solve this issue. 

Different generations of pixel detectors have seen their pixel size
shrink:
from $172 \mu m$ for the Pilatus, $130 \mu m$ for ImXPAD, $75 \mu m$ for the
Eiger and $55 \mu m$ for Medipix-based chips \ldots, and probably less for
future detectors.
As the resolution of the powder diffraction diagram obtained is limited by the
pixel size (and the distance of the detector), this shrinkage of pixel-size
leads naturally to better resolved powder diffraction patterns. 
Unfortunately, to keep the surface of the detector constant, one would need
to multiply the number of pixels by the square of this value, and the
associated infrastructure for read-out and data-transfer. 
Moving the detector in front of the sample offers a flexibility which
partially removes this limitation.

\section{Conclusion}

The new graphical user interface for pyFAI has been developed to ease the
calibration of the experimental setup with fixed detector, especially for first
time users.
Once those fixed position have been described, they can be fitted together to
determine the detector position at any goniometer position. 
By acquiring multiple images a various positions, images can be
integrated together to provide a high-$q$ powder diffraction pattern of
quality equivalent to the one acquired with a much larger detector. 

 
\ack{Acknowledgements}

We would like to thank all ESRF beam-line teams for supporting the
pyFAI development, and especially David Flot from the MX-group who provided the
data of the translation table and the two CRG beamlines BM02 (D2AM) and BM20
(ROBL) for the goniometer data. 
They gracefully provided beam-time and test-data to allow debugging this 
goniometer optimization tool.
We would also like to thank the French CNRS for financing the IR-DRX project
in 2015 and 2016 which acted as a catalyzer on the goniometer refinement,
and the other participants to the project, especially Serge Cohen from the
Ipanema institute, the DiffAbs beamline and Frédéric-Emmanuel Picca from
Synchrotron Soleil.
In the instrumentation division (ISDD) from ESRF  we would like to thank V. A.
Solé, head of data analysis unit and leader of the \textit{silx} project, and all our
colleagues from the silx project: Thomas Vincent, Henri Payno, Damien Naudet and
Pierre Knobel.

\bibliographystyle{iucr}
\bibliography{biblio}


\end{document}
